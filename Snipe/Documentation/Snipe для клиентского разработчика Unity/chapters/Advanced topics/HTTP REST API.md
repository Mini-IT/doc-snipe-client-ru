#miniit #snipe 

>[!note]
>HTTP Transport уже реализован в коммуникаторе. Достаточно лишь задать значения в конфиге. Дополнительных действий не требуется.
>Данная статья поможет понять, как это работает изнутри

Альтернатива Websocket и UDP версиям протокола. Позволяет клиенту работать когда нет нужды в постоянном соединении или необходима максимально простая и надежная работа с сервером.

Базовый запрос ровно один:

`POST` [`https://dev.snipe.dev/api/v1/request/[type]`](https://dev.snipe.dev/api/v1/request/:type:)

Здесь type не используется в обработке, но его нужно все равно отсылать чтобы писался в логи нгинкса для возможного последующего использования

тело - JSON, обычный наш формат сообщения: `{ t:string, id:int, data:any }`

ответ также JSON в старом формате - `{ t:string, id:int, errorCode:string, data:any }`

Предполагается следующее. Сперва клиент шлет `auth.registerAndLogin` или `user.login`, в ответе на `user.login` вдобавок к старым полям будет `token:string`. Этим токеном надо подписывать все дальнейшие запросы в хедере Authorization:

`Authorization: Bearer <token>`

Если от сервера один немедленный ответ, ответ будет запрошенного типа. В ином случае ответы копятся в очередь на стороне сервера и когда клиент делает следующий запрос, ответ будет `t=server.responses`, где `data: []ClientResponse`

Клиент привязывается к инстанцу прокси по айпи адресу, надо будет потом проверить так ли это. В логах `connectionID` будет соблюдаться между разными HTTP-запросами, сессия живет вне от конкретных запросов.

Как правило все ответы имеют статус 200, но есть 401 (ошибка авторизации токеном), 429 (рейт лимит, `errorCode=rateLimit`) и 500 (какая-то серьезная ошибка сервера, сейчас может быть только одна - `errorCode=requestTimeout`).

Если клиенту надо получать ответы, ничего не отправляя (например ожидание в матчмейкинг очереди), то он должен пинговать запросом `server.ping` (получая в ответ `server.ping` или `server.responses`). Решили, что по умолчанию это должно быть **ОТКЛЮЧЕНО**, и включаться флагом при компиляции - с целью избегания ненужного спама во всех проектах, где не нужен рилтайм или всегда будет один ответ на запрос.

В случае запроса на авторизацию `auth.registerAndLogin` сделан хак, поскольку на него всегда будет два ответа (`user.login` и `auth.registerAndLogin`), чтобы потом не пинговать. В этом случае ответ на него всегда будет `server.responses` со списком из двух записей.

Несложные тесты показали что у HTTP-версии оверхед в 25% по времени работы (в основном от того, что msgpack сильно интегрирован во всю цепочку, приходится получать msgpack от сервиса, декодить его в обьект, и потом реэнкодить в JSON, это нужно также и для батчинга ответов).

Поддерживается батчинг сообщений: `{ t=server.batch, data: { list: []ClientRequest } }`. Сервер ждет пока от сервисов не придут все ответы, и формирует в ответ `t=server.responses`.