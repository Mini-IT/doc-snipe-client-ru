В большинстве проектов в основной массе случаев хранение данных в профиле делается простым образом через атрибуты игрока:
 - В Снайп редакторе в разделе `Entities/Player/Attribute Types` ПМ или ГД объявляет новый тип атрибута (задаются имя атрибута, строковый ид, тип и права доступа)
     - Типы бывают следующие:
         - Array<Int>
         - Boolean
         - Float
         - Int
         - Object - обьект, сериализуемый в JSON
         - String - строка, **максимальная длина 16кб**
         - Timestamp - надстройка над Int, ничем не отличается, только в редакторе игрока парсится в дату
     - Права доступа бывают следующие:
       - На чтение: private/public/internal
         - private - клиент может прочитать свои атрибуты, но не может чужие
         - public - клиент может прочитать свой или чужой атрибуты
         - internal - доступны только в серверных скриптах и не экспортируются в Снайп API
       - На запись: private/internal
           - private - клиент может записать значение в этот атрибут напрямую
           - internal - клиент не может записать значение в этот атрибут, это можно сделать только в серверном скрипте
           - Изменить атрибут в чужом профиле невозможно напрямую 
 - В проекте перекачивается Снайп API и в UserAttributes появляется новое поле с именем как в строковом иде, например `SnipeApi.Context.Api.UserAttr.UserAttributes.coins`. Поле строго типизовано. Иногда это оборачивается в `UserDataService`.
   - Под капотом API атрибуты профиля обычно считываются один раз при старте игры через запросы `UserAttr.GetAll()`, `UserAttr.GetPublic()`, `UserAttr.GetPrivate()`, которые преобразуются в запросы сервера c типами `attr.getAll`, `attr.getPublic`, `attr.getPrivate`. При этом каждое присвоение атрибута приводит к аналогичным запросам `UserAttr.Set()`, `UserAttr.SetMulti()`. В некоторых проектах и случаях эти запросы вызываются вручную. Запросы на сет батчатся по настраиваемому в проекте таймауту, чтобы сократить их количество.
   - Следует всегда помнить об этом, и стараться минимизировать количество отправляемых запросов на сервер. В большинстве случаев это происходит автоматически, но, например, был замечен случай, где в профиль игрока сохранили таймер, число секунд, которое инкрементировалось раз в секунду, вызывая непрерывный поток запросов на сервер. Так делать нельзя.

В базе данных профиль игрока сериализуется в JSON.

Этой информации и подхода как правило хватает, пока не приходит время и желание записать в профиль структурированные данные, которые не влазят в простые типы. Очевидным решением является сериализация в JSON и потом запись в атрибут строку. Здесь программист проекта должен задать себе и ГД вопросы, какого размера будут эти данные сейчас? Через месяц? Через год? И от ответа на эти вопросы будет зависеть, можно ли просто использовать JSON и забыть.

Во-первых, fastJSON в частности имеет особенность, сохранять информацию о типе объекта в JSON. Это неэффективно само по себе, и сильно влияет на размер данных:
```csharp
var testDictionary = new Dictionary<int, object>
{
    { 1, "String value" },
    { 2, 12345 },
    { 3, new Level { LevelID = 15, LevelState = 1, Stars = 2 } }
};
```

Становится (форматирование добавлено для лучшего чтения):
```json
[
  {
    "k":1,
    "v":"String value"
  },
  {
    "k":2,
    "v":12345
  },
  {
    "k":3,
    "v":{
      "$type":"FastJsonExample.Level, euj54ar3, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
      "LevelID":15,
      "LevelState":1,
      "Stars":2
    }
  }
]
```

Любой массив однотипных объектов будет сохранять информацию типа в каждой записи. Рассмотрим это на примере. Пусть игрок проходит в игре уровни и сохраняет статус прохождения уровня и число полученных звезд:

```csharp
var levels = new List<object>
{
    new { LevelID = 1, LevelState = 1, Stars = 3 },
    new { LevelID = 2, LevelState = 2, Stars = 3 },
    new { LevelID = 3, LevelState = 0, Stars = 1 },
    // ...
};
```

Мы получаем подобную запись:
```json
[{"$type":"FastJsonExample.Level, uaraywle, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null","LevelID":1,"LevelState":1,"Stars":3},{"$type":"FastJsonExample.Level, uaraywle, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null","LevelID":2,"LevelState":2,"Stars":3},{"$type":"FastJsonExample.Level, uaraywle, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null","LevelID":3,"LevelState":0,"Stars":1}]
```

Это можно сохранить в профиль и отметить задачу решенной, но такое решение приведет к следующим проблемам. Прикинем сколько занимает одна запись уровня: `{"$type":"FastJsonExample.Level, uaraywle, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null","LevelID":1,"LevelState":1,"Stars":3}` - 135 байт. Предположим, уровни в игре бесконечные и игрок может пройти 100 уровней в день (это выясняется у ГД). На выходе имеем 13.5кб. То есть через день активный игрок упрется в максимально допустимый размер строки 16кб. Пусть вместо строки мы прямо сохраняем массив в поле типа Object. В этом случае ограничений в профиле нет, и он будет расти с каждым пройденным уровнем. За месяц это будет 30 * 13.5 = 405кб (помним, что все равно всё станет в итоге JSON-ом). Это является серьезной проблемой, потому что на каждое прохождение уровня запись будет отправляться целиком на каждый сет (запрос `attr.set` или `attr.setMulti` если атрибутов несколько) и качаться целиком на каждый гет (`attr.getAll`, `attr.get`, `attr.getPrivate`, `attr.getPublic`). Обычно геты атрибутов профиля в проектах без скриптов делаются один раз в начале сессии клиента (запрос `attr.getAll`). То есть клиент не сможет играть, пока не скачает пол-мегабайта (если не реализовано что он играет с локального профиля). Это уже ощутимый лаг при плохом соединении. Аналогично, пересохранение постоянно растущего профиля вызывает потоки аплоад трафика, и может повлиять на качество игры. Не говоря уже о том, что если интернет слабый или игрок имеет тенденцию переключаться в другие приложения, сообщения такого размера часто будут теряться, вызывая рассинхрон профиля на сервере и клиенте.

Здесь нужно оптимизировать формат хранения данных. Самое очевидное, можно выставить `UseExtensions = false` в параметрах сериализации и исключить сохранение типа. Тогда один уровень будет занимать `{"LevelID":1,"LevelState":1,"Stars":3},` - 40 байт. За месяц - 30 * 40 * 100 = 120кб. Уже лучше, но мы всегда смотрим сколько профиль будет занимать через год игры (120 * 12 = 1.44 мб). Здесь есть несколько относительно простых общих стратегий, но во многом решение будет зависеть от требований проекта. Реально ли нужно сохранять данные обо всех пройденных уровнях в бесконечной игре? Может быть просто последние 500 уровней и удалять старые из массива? Все ли поля нужны в этом объекте? Может быть, что-то можно исключить? Когда ответы на все эти вопросы будут найдены, мы будем готовы погрузиться в увлекательный мир упаковки данных!

Первая общая стратегия, это не писать имена полей, а только значения. Тогда один уровень в примере будет `1,1,3,` - 6 байт. Здесь нужно иметь ввиду, что при добавлении новых полей придется делать миграцию данных. Но при этом за год игры выйдет 6 * 100 * 365 = 219кб. Многовато, но в некоторых случаях пойдет. Также в некоторых случаях можно не писать запятые, но тогда придется работать с полями фиксированной длины.

В качестве примера, хранение 500 последних уровней в этой стратегии - 500 * 6 = 3кб. Такой размер данных нас устраивает, но может не отвечать требованиям конкретного проекта.

Вторая стратегия сложнее в имплементации и требует бОльших навыков, это побитное сохранение чисел. Если мы знаем что LevelID 1-16384, LevelState 0-3, Stars 0-3, то можно запаковать это в 14+2+2=18 битное число (3 байта). Правда потом это число надо превратить в ASCII строку, для чего использовать base64. Станет 4 байта. Этим лучше заниматься уже после обсуждения с ПМом и другими программистами. Аналогично, изменение структуры данных скорее всего приведет к необходимости писать миграцию.

Следует отметить, что всё вышесказанное имеет место только в случаях т.н. клиентских проектов когда клиент управляет всеми данными профиля напрямую. В случае, когда проекты используют серверные скрипты, эта проблема перекладывается на плечи серверного программиста, но и реже встает, поскольку вместо прямых запросов атрибутов для клиента пишутся скрипты для гета информации, где можно реализовать другие стратегии, например гет списка уровней чанками, а вместо сета просто уведомление сервера о пройденном уровне и его статусе. Нужно иметь ввиду только общий размер данных в БД.
